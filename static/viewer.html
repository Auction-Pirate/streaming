<!DOCTYPE html>
<html>
	<head>
		<title>WebRTC Audio Viewer</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
		<style>
			.container {
				max-width: 800px;
				margin: 0 auto;
				padding: 20px;
			}
			.status {
				margin-top: 10px;
				padding: 10px;
				border-radius: 4px;
				background: #f5f5f5;
				text-align: center;
			}
			.audio-indicator {
				width: 50px;
				height: 50px;
				border-radius: 25px;
				background-color: #ccc;
				margin: 20px auto;
				transition: background-color 0.3s;
			}
			.audio-indicator.active {
				background-color: #4caf50;
			}
			.controls {
				margin: 20px 0;
				padding: 15px;
				background: #fff;
				border-radius: 8px;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
				text-align: center;
			}
			button {
				padding: 10px 20px;
				margin: 0 5px;
				font-size: 16px;
				border: none;
				border-radius: 4px;
				background: #2196f3;
				color: white;
				cursor: pointer;
			}
			button:disabled {
				background: #ccc;
			}
			.volume-meter {
				margin: 20px auto;
				width: 300px;
				height: 20px;
				background: #f0f0f0;
				border-radius: 10px;
				overflow: hidden;
			}
			.volume-level {
				width: 0%;
				height: 100%;
				background: #4caf50;
				transition: width 0.1s;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div id="audioIndicator" class="audio-indicator"></div>
			<div id="status" class="status">Waiting for broadcast...</div>
			<div class="controls">
				<button id="playButton">Play</button>
				<button id="stopButton">Stop</button>
				<button id="muteButton">Mute</button>
			</div>
			<div class="volume-meter">
				<div id="volumeLevel" class="volume-level"></div>
			</div>
		</div>

		<script>
			const statusElement = document.getElementById("status");
			const audioIndicator = document.getElementById("audioIndicator");
			const playButton = document.getElementById("playButton");
			const stopButton = document.getElementById("stopButton");
			const muteButton = document.getElementById("muteButton");
			const volumeLevel = document.getElementById("volumeLevel");

			let pc = null;
			let ws = null;
			let sound = null;

			const config = {
				iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
			};

			function updateStatus(message, color = "black") {
				console.log("Status:", message);
				statusElement.textContent = message;
				statusElement.style.color = color;
				audioIndicator.classList.toggle(
					"active",
					message.includes("Connected")
				);
			}

			async function connectToStream() {
				try {
					cleanup();

					pc = new RTCPeerConnection(config);
					console.log("Created peer connection");

					pc.onicecandidate = (event) => {
						if (event.candidate) {
							console.log("New ICE candidate:", event.candidate);
							if (ws && ws.readyState === WebSocket.OPEN) {
								ws.send(
									JSON.stringify({
										type: "candidate",
										candidate: event.candidate.toJSON(),
									})
								);
							}
						}
					};

					pc.oniceconnectionstatechange = () => {
						console.log("ICE Connection State:", pc.iceConnectionState);
					};

					pc.ontrack = (event) => {
						console.log("Received track:", event.track.kind);
						console.log("Track settings:", event.track.getSettings());

						const audio = document.createElement("audio");
						audio.autoplay = true;
						audio.controls = true;
						document.body.appendChild(audio);

						const stream = new MediaStream([event.track]);
						audio.srcObject = stream;

						// Log when audio starts playing
						audio.onplay = () => console.log("Audio started playing");
						audio.onpause = () => console.log("Audio paused");
						audio.onerror = (e) => console.error("Audio error:", e);

						// Monitor audio levels
						const audioContext = new (window.AudioContext ||
							window.webkitAudioContext)();
						const source = audioContext.createMediaStreamSource(stream);
						const analyser = audioContext.createAnalyser();
						source.connect(analyser);
						source.connect(audioContext.destination);

						const dataArray = new Uint8Array(analyser.frequencyBinCount);
						function updateVolume() {
							analyser.getByteFrequencyData(dataArray);
							const average =
								dataArray.reduce((a, b) => a + b) / dataArray.length;
							console.log("Audio level:", average);
							requestAnimationFrame(updateVolume);
						}
						updateVolume();
					};

					ws = new WebSocket("ws://147.182.138.79:8080/view");

					ws.onopen = async () => {
						console.log("WebSocket connected");
						try {
							const offer = await pc.createOffer({
								offerToReceiveAudio: true,
								offerToReceiveVideo: false,
							});

							await pc.setLocalDescription(offer);
							ws.send(
								JSON.stringify({
									type: "offer",
									sdp: offer.sdp,
								})
							);
						} catch (err) {
							console.error("Error in offer creation:", err);
						}
					};

					ws.onmessage = async (e) => {
						try {
							const msg = JSON.parse(e.data);
							console.log("Received message type:", msg.type);

							if (msg.type === "answer") {
								await pc.setRemoteDescription(
									new RTCSessionDescription({
										type: "answer",
										sdp: msg.sdp,
									})
								);
							}
						} catch (err) {
							console.error("Error handling message:", err);
						}
					};
				} catch (err) {
					console.error("Error:", err);
					cleanup();
				}
			}

			function cleanup() {
				if (pc) {
					pc.close();
					pc = null;
				}
				if (ws) {
					ws.close();
					ws = null;
				}
			}

			// Button handlers
			playButton.addEventListener("click", () => {
				if (sound) {
					sound.play();
				}
			});

			stopButton.addEventListener("click", () => {
				if (sound) {
					sound.pause();
				}
			});

			muteButton.addEventListener("click", () => {
				if (sound) {
					sound.mute(!sound.mute());
					muteButton.textContent = sound.mute() ? "Unmute" : "Mute";
				}
			});

			// Start checking for broadcast
			async function checkBroadcastStatus() {
				try {
					const response = await fetch("/broadcast-status");
					const data = await response.json();

					if (data.broadcasting && !pc) {
						console.log("Broadcast detected, connecting...");
						await connectToStream();
					} else if (!data.broadcasting && pc) {
						console.log("Broadcast ended");
						cleanup();
					}
				} catch (err) {
					console.error("Error checking broadcast status:", err);
				}
			}

			checkBroadcastStatus();
			setInterval(checkBroadcastStatus, 2000);

			// Cleanup on page unload
			window.onbeforeunload = cleanup;
		</script>
	</body>
</html>

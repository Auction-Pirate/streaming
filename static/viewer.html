<!DOCTYPE html>
<html>
	<head>
		<title>WebRTC Audio Viewer</title>
		<style>
			.container {
				max-width: 800px;
				margin: 0 auto;
				padding: 20px;
			}
			.status {
				margin-top: 10px;
				padding: 10px;
				border-radius: 4px;
				background: #f5f5f5;
				text-align: center;
			}
			.audio-indicator {
				width: 50px;
				height: 50px;
				border-radius: 25px;
				background-color: #ccc;
				margin: 20px auto;
				transition: background-color 0.3s;
			}
			.audio-indicator.active {
				background-color: #4caf50;
			}
			.controls {
				margin: 20px 0;
				padding: 15px;
				background: #fff;
				border-radius: 8px;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
				text-align: center;
			}
			button {
				padding: 10px 20px;
				margin: 0 5px;
				font-size: 16px;
				border: none;
				border-radius: 4px;
				background: #2196f3;
				color: white;
				cursor: pointer;
			}
			button:disabled {
				background: #ccc;
			}
			.volume-meter {
				margin: 20px auto;
				width: 300px;
				height: 20px;
				background: #f0f0f0;
				border-radius: 10px;
				overflow: hidden;
			}
			.volume-level {
				width: 0%;
				height: 100%;
				background: #4caf50;
				transition: width 0.1s;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div id="audioIndicator" class="audio-indicator"></div>
			<div id="status" class="status">Waiting for broadcast...</div>
			<div class="controls">
				<button id="playButton">Play</button>
				<button id="stopButton">Stop</button>
				<button id="muteButton">Mute</button>
			</div>
			<div class="volume-meter">
				<div id="volumeLevel" class="volume-level"></div>
			</div>
			<audio id="audio" autoplay></audio>
		</div>

		<script>
			const audio = document.getElementById("audio");
			const statusElement = document.getElementById("status");
			const audioIndicator = document.getElementById("audioIndicator");
			let pc = null;
			let ws = null;
			let audioContext = null;
			let audioAnalyser = null;
			let dataArray = null;
			let animationFrame = null;
			const playButton = document.getElementById("playButton");
			const stopButton = document.getElementById("stopButton");
			const muteButton = document.getElementById("muteButton");
			const volumeLevel = document.getElementById("volumeLevel");

			const config = {
				iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
			};

			function updateStatus(message, color = "black") {
				console.log("Status:", message);
				statusElement.textContent = message;
				statusElement.style.color = color;
				audioIndicator.classList.toggle(
					"active",
					message.includes("Connected")
				);
			}

			async function connectToStream() {
				try {
					cleanup();

					pc = new RTCPeerConnection(config);
					console.log("Created peer connection");

					pc.onicecandidate = (event) => {
						if (event.candidate) {
							console.log("New ICE candidate:", event.candidate);
							if (ws && ws.readyState === WebSocket.OPEN) {
								ws.send(
									JSON.stringify({
										type: "candidate",
										candidate: event.candidate.toJSON(),
									})
								);
							}
						}
					};

					pc.oniceconnectionstatechange = () => {
						console.log("ICE Connection State:", pc.iceConnectionState);
						if (pc.iceConnectionState === "connected") {
							updateStatus("Connected to broadcast", "#4CAF50");
						} else if (pc.iceConnectionState === "disconnected") {
							updateStatus("Disconnected from broadcast", "#FFA500");
						}
					};

					pc.onconnectionstatechange = () => {
						console.log("Connection state:", pc.connectionState);
					};

					pc.onsignalingstatechange = () => {
						console.log("Signaling state:", pc.signalingState);
					};

					pc.ontrack = (event) => {
						console.log("Received track:", event.track.kind);
						console.log("Track settings:", event.track.getSettings());
						console.log("Track constraints:", event.track.getConstraints());
						console.log("Track state:", event.track.readyState);

						if (event.track.kind === "audio") {
							const audioStream = new MediaStream([event.track]);
							audio.srcObject = audioStream;

							// Add track ended handler
							event.track.onended = () => {
								console.log("Audio track ended");
							};

							// Add track mute handler
							event.track.onmute = () => {
								console.log("Audio track muted");
							};

							// Add track unmute handler
							event.track.onunmute = () => {
								console.log("Audio track unmuted");
							};

							setupAudioAnalyser(audioStream);

							audio
								.play()
								.then(() => {
									console.log("Audio playing successfully");
									console.log("Audio element state:", {
										readyState: audio.readyState,
										paused: audio.paused,
										muted: audio.muted,
										volume: audio.volume,
									});
									updatePlaybackState();
								})
								.catch((err) => console.error("Error playing audio:", err));

							updateStatus("Receiving audio", "#4CAF50");
						}
					};

					ws = new WebSocket("ws://147.182.138.79:8080/view");

					ws.onopen = async () => {
						console.log("WebSocket connected");
						try {
							const offer = await pc.createOffer({
								offerToReceiveAudio: true,
								offerToReceiveVideo: false,
								voiceActivityDetection: true,
								iceRestart: true,
							});

							console.log("Created offer:", offer);
							await pc.setLocalDescription(offer);
							console.log("Set local description");

							ws.send(
								JSON.stringify({
									type: "offer",
									sdp: offer.sdp,
								})
							);
							console.log("Sent offer to server");
						} catch (err) {
							console.error("Error in offer creation:", err);
						}
					};

					ws.onclose = () => {
						console.log("WebSocket closed");
						cleanup();
						updateStatus("Connection lost, waiting for broadcast...", "#999");
					};

					ws.onerror = (error) => {
						console.error("WebSocket Error:", error);
						updateStatus("Connection error", "#F44336");
					};

					ws.onmessage = async (e) => {
						try {
							const msg = JSON.parse(e.data);
							console.log("Received message type:", msg.type);

							switch (msg.type) {
								case "answer":
									const answer = new RTCSessionDescription({
										type: "answer",
										sdp: msg.sdp,
									});
									await pc.setRemoteDescription(answer);
									console.log("Set remote description");
									break;

								case "candidate":
									if (msg.candidate) {
										try {
											await pc.addIceCandidate(
												new RTCIceCandidate(msg.candidate)
											);
											console.log("Added ICE candidate");
										} catch (err) {
											console.error("Error adding ICE candidate:", err);
										}
									}
									break;
							}
						} catch (err) {
							console.error("Error handling message:", err);
						}
					};
				} catch (err) {
					console.error("Error connecting to stream:", err);
					updateStatus("Error: " + err.message, "#F44336");
					cleanup();
				}
			}

			function cleanup() {
				if (pc) {
					pc.close();
					pc = null;
				}
				if (ws) {
					ws.close();
					ws = null;
				}
				if (audioContext) {
					audioContext.close();
					audioContext = null;
				}
				if (animationFrame) {
					cancelAnimationFrame(animationFrame);
					animationFrame = null;
				}
				audio.srcObject = null;
				audioIndicator.classList.remove("active");
				volumeLevel.style.width = "0%";
				updatePlaybackState();
			}

			async function checkBroadcastStatus() {
				try {
					const response = await fetch("/broadcast-status");
					const data = await response.json();

					if (data.broadcasting && !pc) {
						console.log("Broadcast detected, connecting...");
						updateStatus("Connecting to broadcast...", "#FFA500");
						await connectToStream();
					} else if (!data.broadcasting && pc) {
						console.log("Broadcast ended");
						cleanup();
						updateStatus("Waiting for broadcast...", "#999");
					}
				} catch (err) {
					console.error("Error checking broadcast status:", err);
				}
			}

			playButton.addEventListener("click", () => {
				audio.play();
				updatePlaybackState();
			});

			stopButton.addEventListener("click", () => {
				audio.pause();
				updatePlaybackState();
			});

			muteButton.addEventListener("click", () => {
				audio.muted = !audio.muted;
				muteButton.textContent = audio.muted ? "Unmute" : "Mute";
			});

			function updatePlaybackState() {
				playButton.disabled = !audio.paused;
				stopButton.disabled = audio.paused;
			}

			function setupAudioAnalyser(stream) {
				if (!audioContext) {
					audioContext = new (window.AudioContext ||
						window.webkitAudioContext)();
				}

				// Create audio source from stream
				const source = audioContext.createMediaStreamSource(stream);
				audioAnalyser = audioContext.createAnalyser();
				audioAnalyser.fftSize = 256;
				source.connect(audioAnalyser);

				// Create data array for volume levels
				dataArray = new Uint8Array(audioAnalyser.frequencyBinCount);

				// Start animation
				animateVolumeMeter();
			}

			function animateVolumeMeter() {
				if (!audioAnalyser || !dataArray) return;

				audioAnalyser.getByteFrequencyData(dataArray);
				const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
				const volume = Math.min(100, Math.round((average / 255) * 100));

				volumeLevel.style.width = volume + "%";
				volumeLevel.style.backgroundColor = volume > 50 ? "#ff4444" : "#4caf50";

				animationFrame = requestAnimationFrame(animateVolumeMeter);
			}

			// Start checking for broadcast immediately
			checkBroadcastStatus();

			// Check for broadcast status every 2 seconds
			setInterval(checkBroadcastStatus, 2000);

			// Cleanup on page unload
			window.onbeforeunload = cleanup;

			// Add these after the audio element is defined
			audio.onloadedmetadata = () => {
				console.log("Audio metadata loaded");
			};

			audio.oncanplay = () => {
				console.log("Audio can play");
			};

			audio.onplay = () => {
				console.log("Audio started playing");
			};

			audio.onpause = () => {
				console.log("Audio paused");
			};

			audio.onerror = (e) => {
				console.error("Audio error:", audio.error);
			};
		</script>
	</body>
</html>

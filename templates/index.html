<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{if .IsBroadcaster}}Broadcast{{else}}View{{end}} Stream</title>
		<link href="https://vjs.zencdn.net/8.6.1/video-js.css" rel="stylesheet" />
		<style>
			body {
				margin: 0;
				padding: 20px;
				font-family: Arial, sans-serif;
				background: #f0f0f0;
			}
			.container {
				max-width: 1200px;
				margin: 0 auto;
			}
			.video-container {
				position: relative;
				background: #000;
				border-radius: 8px;
				overflow: hidden;
				margin-bottom: 20px;
				aspect-ratio: 16/9;
			}
			.video-js {
				width: 100%;
				height: 100%;
				border-radius: 8px;
			}
			.video-js.vjs-playing .vjs-tech {
				pointer-events: none;
			}
			.controls {
				padding: 15px;
				background: #fff;
				border-radius: 8px;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			}
			button {
				padding: 10px 20px;
				font-size: 16px;
				border: none;
				border-radius: 4px;
				background: #2196f3;
				color: white;
				cursor: pointer;
				margin-right: 10px;
			}
			button:hover {
				background: #1976d2;
			}
			button:disabled {
				background: #ccc;
				cursor: not-allowed;
			}
			.status {
				display: inline-block;
				padding: 8px 12px;
				border-radius: 4px;
				margin-left: 10px;
			}
			.stream-key {
				margin-bottom: 20px;
				padding: 15px;
				background: #fff;
				border-radius: 8px;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			}
		</style>
	</head>
	<body>
		<div class="container">
			{{if .IsBroadcaster}}
			<div class="stream-key">
				<h3>Stream Key</h3>
				<p>Your stream key: <strong>{{.StreamKey}}</strong></p>
			</div>
			{{end}}

			<div class="video-container">
				<video
					id="video"
					class="video-js vjs-default-skin vjs-big-play-button vjs-fluid"
					playsinline
					{{if
					.IsBroadcaster}}muted{{end}}
				>
					<p class="vjs-no-js">
						To view this video please enable JavaScript, and consider upgrading
						to a web browser that supports HTML5 video
					</p>
				</video>
			</div>

			<div class="controls">
				{{if .IsBroadcaster}}
				<button id="startButton">Start Broadcasting</button>
				<button id="stopButton" disabled>Stop Broadcasting</button>
				{{end}}
				<span id="status" class="status">Disconnected</span>
			</div>
		</div>

		<script src="https://vjs.zencdn.net/8.6.1/video.min.js"></script>

		<script>
			let player;
			const config = {
			    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
			};

			let pc = null;
			let ws = null;
			let stream = null;

			player = videojs('video', {
			    controls: true,
			    autoplay: {{if .IsBroadcaster}}false{{else}}true{{end}},
			    fluid: true,
			    playsinline: true,
			    liveui: true,
			    responsive: true,
			    controlBar: {
			        playToggle: {{if .IsBroadcaster}}false{{else}}true{{end}},
			        volumePanel: { inline: false },
			        pictureInPictureToggle: true,
			        fullscreenToggle: true,
			    }
			});

			const statusElement = document.getElementById('status');
			{{if .IsBroadcaster}}
			const startButton = document.getElementById('startButton');
			const stopButton = document.getElementById('stopButton');

			async function startBroadcast() {
			    try {
			        // Create WebRTC peer connection first
			        pc = new RTCPeerConnection(config);
			        console.log('Created peer connection:', pc);

			        // Get media stream
			        stream = await navigator.mediaDevices.getUserMedia({
			            video: {
			                width: 1280,
			                height: 720,
			                frameRate: 30,
			                facingMode: 'user'
			            },
			            audio: {
			                echoCancellation: true,
			                noiseSuppression: true,
			                sampleRate: 44100
			            }
			        });

			        console.log('Got media stream:', stream);

			        // Set up Video.js with the stream
			        if (player) {
			            // Create a new MediaStream from the tracks
			            const mediaStream = new MediaStream(stream.getTracks());

			            // Create a video element for the stream
			            const videoElement = document.createElement('video');
			            videoElement.srcObject = mediaStream;
			            videoElement.setAttribute('playsinline', '');

			            // Set the video element as the source for Video.js
			            player.tech().setSource({
			                src: URL.createObjectURL(mediaStream),
			                type: 'video/mp4'
			            });

			            player.play().catch(function(error) {
			                console.log("Video play error:", error);
			            });
			        }

			        // Add tracks to peer connection
			        stream.getTracks().forEach(track => {
			            console.log('Adding track to peer connection:', track);
			            pc.addTrack(track, stream);
			        });

			        // Create WebSocket connection
			        ws = new WebSocket('ws://147.182.138.79:8080/broadcast');

			        ws.onopen = async () => {
			            console.log('WebSocket connected, creating offer');
			            try {
			                const offer = await pc.createOffer({
			                    offerToReceiveAudio: true,
			                    offerToReceiveVideo: true
			                });
			                console.log('Created offer:', offer);

			                await pc.setLocalDescription(offer);
			                console.log('Set local description');

			                ws.send(JSON.stringify({
			                    type: 'offer',
			                    data: offer.sdp,
			                    streamKey: '{{.StreamKey}}'
			                }));
			                console.log('Sent offer to server');
			            } catch (err) {
			                console.error('Error during offer creation:', err);
			            }
			        };

			        ws.onmessage = async (e) => {
			            try {
			                const msg = JSON.parse(e.data);
			                console.log('Received message:', msg);
			                if (msg.type === 'answer') {
			                    const answer = new RTCSessionDescription({
			                        type: 'answer',
			                        sdp: msg.data
			                    });
			                    await pc.setRemoteDescription(answer);
			                    console.log('Set remote description');
			                }
			            } catch (err) {
			                console.error('Error handling message:', err);
			            }
			        };

			        startButton.disabled = true;
			        stopButton.disabled = false;
			        updateStatus('Broadcasting', '#4CAF50');
			    } catch (err) {
			        console.error('Error:', err);
			        updateStatus('Error: ' + err.message, '#f44336');
			        stopBroadcast();
			    }
			}

			function stopBroadcast() {
			    console.log('Stopping broadcast');
			    if (stream) {
			        stream.getTracks().forEach(track => {
			            track.stop();
			            console.log(`Stopped ${track.kind} track`);
			        });
			    }
			    if (pc) {
			        pc.close();
			        console.log('Closed peer connection');
			    }
			    if (ws) {
			        ws.close();
			        console.log('Closed WebSocket');
			    }
			    if (player) {
			        player.reset();
			        player.src({ type: 'video/mp4', src: '' });
			    }
			    startButton.disabled = false;
			    stopButton.disabled = true;
			    updateStatus('Disconnected');
			}

			startButton.onclick = startBroadcast;
			stopButton.onclick = stopBroadcast;
			{{else}}
			// Viewer code
			async function startViewing() {
			    try {
			        pc = new RTCPeerConnection(config);
			        ws = new WebSocket('ws://147.182.138.79:8080/view');

			        pc.ontrack = (event) => {
			            player.srcObject = event.streams[0];
			        };

			        pc.oniceconnectionstatechange = () => {
			            updateStatus(`ICE Connection: ${pc.iceConnectionState}`);
			        };

			        ws.onopen = async () => {
			            const offer = await pc.createOffer({
			                offerToReceiveVideo: true,
			                offerToReceiveAudio: true
			            });
			            await pc.setLocalDescription(offer);

			            ws.send(JSON.stringify({
			                type: 'offer',
			                data: offer.sdp
			            }));
			        };

			        ws.onmessage = async (e) => {
			            const msg = JSON.parse(e.data);
			            if (msg.type === 'answer') {
			                await pc.setRemoteDescription(new RTCSessionDescription({
			                    type: 'answer',
			                    sdp: msg.data
			                }));
			            }
			        };

			        ws.onerror = (error) => {
			            console.error('WebSocket Error:', error);
			            updateStatus('Connection Error', '#f44336');
			        };

			        updateStatus('Connected', '#4CAF50');
			    } catch (err) {
			        console.error('Error:', err);
			        updateStatus('Error: ' + err.message, '#f44336');
			    }
			}

			startViewing();
			{{end}}

			function updateStatus(status, color = '#000') {
			    statusElement.textContent = status;
			    statusElement.style.color = color;
			}

			// Clean up Video.js on page unload
			window.onbeforeunload = function() {
			    if (player) {
			        player.dispose();
			    }
			};
		</script>
	</body>
</html>

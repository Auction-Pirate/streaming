<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{if .IsBroadcaster}}Broadcast{{else}}View{{end}} Stream</title>
		<style>
			/* ... previous styles remain the same ... */
		</style>
	</head>
	<body>
		<div class="container">
			{{if .IsBroadcaster}}
			<div class="stream-key">
				<h3>Stream Key</h3>
				<p>Your stream key: <strong>{{.StreamKey}}</strong></p>
			</div>
			{{end}}

			<div class="video-container">
				<video
					id="video"
					playsinline
					{{if
					not
					.IsBroadcaster}}autoplay{{end}}
				></video>
			</div>

			<div class="controls">
				{{if .IsBroadcaster}}
				<button id="startButton">Start Broadcasting</button>
				<button id="stopButton" disabled>Stop Broadcasting</button>
				{{end}}
				<span id="status" class="status">Disconnected</span>
			</div>
		</div>

		<script>
			const config = {
			    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
			};

			let pc = null;
			let ws = null;
			let stream = null;

			const videoElement = document.getElementById('video');
			const statusElement = document.getElementById('status');
			{{if .IsBroadcaster}}
			const startButton = document.getElementById('startButton');
			const stopButton = document.getElementById('stopButton');

			async function startBroadcast() {
			    try {
			        // Check if mediaDevices is supported
			        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
			            throw new Error('Your browser does not support media devices. Please use a modern browser.');
			        }

			        // Request access to media devices with constraints
			        stream = await navigator.mediaDevices.getUserMedia({
			            video: {
			                width: { ideal: 1280 },
			                height: { ideal: 720 }
			            },
			            audio: true
			        }).catch(err => {
			            throw new Error('Failed to access camera/microphone: ' + err.message);
			        });

			        // Display the stream in the video element
			        videoElement.srcObject = stream;
			        await videoElement.play().catch(err => {
			            throw new Error('Failed to play video: ' + err.message);
			        });

			        // Create WebRTC peer connection
			        pc = new RTCPeerConnection(config);
			        ws = new WebSocket('{{.ServerWSURL}}/broadcast');

			        // Add tracks to the peer connection
			        stream.getTracks().forEach(track => {
			            pc.addTrack(track, stream);
			        });

			        // Handle ICE candidate events
			        pc.onicecandidate = event => {
			            if (event.candidate) {
			                console.log("New ICE candidate:", event.candidate);
			            }
			        };

			        pc.oniceconnectionstatechange = () => {
			            updateStatus(`ICE Connection: ${pc.iceConnectionState}`);
			        };

			        // Handle WebSocket connection
			        ws.onopen = async () => {
			            // Create and send offer
			            const offer = await pc.createOffer();
			            await pc.setLocalDescription(offer);

			            ws.send(JSON.stringify({
			                type: 'offer',
			                data: offer.sdp,
			                streamKey: '{{.StreamKey}}'
			            }));
			        };

			        ws.onmessage = async (e) => {
			            const msg = JSON.parse(e.data);
			            if (msg.type === 'answer') {
			                await pc.setRemoteDescription(new RTCSessionDescription({
			                    type: 'answer',
			                    sdp: msg.data
			                }));
			            }
			        };

			        ws.onerror = (error) => {
			            console.error('WebSocket Error:', error);
			            updateStatus('Connection Error', '#f44336');
			        };

			        startButton.disabled = true;
			        stopButton.disabled = false;
			        updateStatus('Broadcasting', '#4CAF50');
			    } catch (err) {
			        console.error('Error:', err);
			        updateStatus('Error: ' + err.message, '#f44336');
			        stopBroadcast(); // Clean up any partial setup
			    }
			}

			function stopBroadcast() {
			    if (stream) {
			        stream.getTracks().forEach(track => track.stop());
			    }
			    if (pc) {
			        pc.close();
			    }
			    if (ws) {
			        ws.close();
			    }
			    videoElement.srcObject = null;
			    startButton.disabled = false;
			    stopButton.disabled = true;
			    updateStatus('Disconnected');
			}

			startButton.onclick = startBroadcast;
			stopButton.onclick = stopBroadcast;
			{{else}}
			// Viewer code
			async function startViewing() {
			    try {
			        pc = new RTCPeerConnection(config);
			        ws = new WebSocket('{{.ServerWSURL}}/view');

			        pc.ontrack = (event) => {
			            if (videoElement.srcObject !== event.streams[0]) {
			                videoElement.srcObject = event.streams[0];
			            }
			        };

			        pc.oniceconnectionstatechange = () => {
			            updateStatus(`ICE Connection: ${pc.iceConnectionState}`);
			        };

			        ws.onopen = async () => {
			            const offer = await pc.createOffer({
			                offerToReceiveVideo: true,
			                offerToReceiveAudio: true
			            });
			            await pc.setLocalDescription(offer);

			            ws.send(JSON.stringify({
			                type: 'offer',
			                data: offer.sdp
			            }));
			        };

			        ws.onmessage = async (e) => {
			            const msg = JSON.parse(e.data);
			            if (msg.type === 'answer') {
			                await pc.setRemoteDescription(new RTCSessionDescription({
			                    type: 'answer',
			                    sdp: msg.data
			                }));
			            }
			        };

			        ws.onerror = (error) => {
			            console.error('WebSocket Error:', error);
			            updateStatus('Connection Error', '#f44336');
			        };

			        updateStatus('Connected', '#4CAF50');
			    } catch (err) {
			        console.error('Error:', err);
			        updateStatus('Error: ' + err.message, '#f44336');
			    }
			}

			startViewing();
			{{end}}

			function updateStatus(status, color = '#000') {
			    statusElement.textContent = status;
			    statusElement.style.color = color;
			}
		</script>
	</body>
</html>
